<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · VariableFrequencyOPF.jl</title><link rel="canonical" href="https://WISPO-POP.github.io/VariableFrequencyOPF.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VariableFrequencyOPF.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="VariableFrequencyOPF.jl"><a class="docs-heading-anchor" href="#VariableFrequencyOPF.jl">VariableFrequencyOPF.jl</a><a id="VariableFrequencyOPF.jl-1"></a><a class="docs-heading-anchor-permalink" href="#VariableFrequencyOPF.jl" title="Permalink"></a></h1><p>AC optimal power flow for networks with multiple frequencies, with each frequency as an optimization variable.</p><p>One main goal of this package is a flexible and extensible implementation which can fully accommodate the multiple and variable frequency OPF formulation with power flow control between frequency areas. This package allows additional modifications to the constraints and objective function as the analysis develops.</p><p>Another goal is a smooth extension of existing data formats to the case of multiple and variable frequencies. To this end, it is important that the software can import industry standard steady state network modeling formats with the minimum necessary additional specification of the parameters which are new to this framework.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>Add this package with the following command in the Julia REPL:</p><pre><code class="language-none">] add git@github.com:WISPO-POP/VariableFrequencyOPF.jl.git</code></pre><p>or</p><pre><code class="language-none">] add https://github.com/WISPO-POP/VariableFrequencyOPF.jl.git</code></pre><p>Load the package:</p><pre><code class="language-none">using VariableFrequencyOPF</code></pre><p>You can also run the package tests:</p><pre><code class="language-none">] test VariableFrequencyOPF</code></pre><h3 id="Parsing-Network-Data"><a class="docs-heading-anchor" href="#Parsing-Network-Data">Parsing Network Data</a><a id="Parsing-Network-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-Network-Data" title="Permalink"></a></h3><p><img src="examples/fig/flowchart_parsing.svg" alt="Flowchart for parsing"/></p><h4 id="Input-data"><a class="docs-heading-anchor" href="#Input-data">Input data</a><a id="Input-data-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data" title="Permalink"></a></h4><p>Each frequency area, or subnetwork, is described by a network data file in a standard format, including PSS&amp;reg;E <em>.raw</em> files, Matpower <em>.m</em> files, or PowerModels dictionaries saved in formats such as <em>.json</em>.</p><p>The file <em>subnetworks.csv</em> contains the names of the network data files for each subnetwork, in the order in which they are to be parsed, and the subnetwork-wide frequency parameters, including a boolean specification of whether the frequency is variable, the base frequency at which the impedance parameters in the network file are defined, and the range of allowed frequencies. An example <em>subnetworks.csv</em> is shown here:</p><table><tr><th style="text-align: right">index</th><th style="text-align: right">file</th><th style="text-align: right">variable_f</th><th style="text-align: right">f_base</th><th style="text-align: right">f_min</th><th style="text-align: right">f_max</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">base_subnet.raw</td><td style="text-align: right">false</td><td style="text-align: right">60</td><td style="text-align: right">60</td><td style="text-align: right">60</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">lfac_subnet.raw</td><td style="text-align: right">true</td><td style="text-align: right">60</td><td style="text-align: right">10</td><td style="text-align: right">50</td></tr></table><p>The file <em>interfaces.csv</em> specifies all the connections between different subnetworks. Each interface is given a unique integer index, and each row in the file which has this interface index specifies a connection to the interface. The rows specify the subnetwork and bus, along with any additional parameters, including the maximum apparent power in per unit. An example <em>interfaces.csv</em> file is shown below.</p><table><tr><th style="text-align: right">index</th><th style="text-align: right">subnet_index</th><th style="text-align: right">bus</th><th style="text-align: right">s_max</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right">1011</td><td style="text-align: right">10.0</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">1</td><td style="text-align: right">1013</td><td style="text-align: right">10.0</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">2</td><td style="text-align: right">1</td><td style="text-align: right">10.0</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">2</td><td style="text-align: right">2</td><td style="text-align: right">10.0</td></tr></table><p>This example shows two interfaces. The first connects bus 1011 in subnetwork 1 to bus 1 in subnetwork 2, and the second connects bus 1013 in subnetwork 1 to bus 2 in subnetwork 2. The apparent power limit at each interface connection is 10.0 p.u.</p><h3 id="Modeling-and-Solving-the-OPF"><a class="docs-heading-anchor" href="#Modeling-and-Solving-the-OPF">Modeling and Solving the OPF</a><a id="Modeling-and-Solving-the-OPF-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-and-Solving-the-OPF" title="Permalink"></a></h3><p><img src="examples/fig/flowchart_opf.svg" alt="Flowchart for OPF"/></p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Solve-the-OPF-for-a-network-with-a-variable-frequency-(low-frequency-AC)-portion"><a class="docs-heading-anchor" href="#Solve-the-OPF-for-a-network-with-a-variable-frequency-(low-frequency-AC)-portion">Solve the OPF for a network with a variable frequency (low frequency AC) portion</a><a id="Solve-the-OPF-for-a-network-with-a-variable-frequency-(low-frequency-AC)-portion-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-OPF-for-a-network-with-a-variable-frequency-(low-frequency-AC)-portion" title="Permalink"></a></h3><p>Consider a power system which is divided into two areas connected by AC-AC converters: one operates at a fixed frequency of 60 Hz, and the other is a multi-terminal low frequency AC network, whose frequency can be chosen. In the directory <code>test/data/case14_twoarea</code> is data for a modified IEEE 14 bus network which fits this paradigm, as drawn here, with the variable frequency portion in blue: <img src="examples/fig/14bus_twoarea.svg" alt="14 bus network with LFAC"/></p><p>In this example, we solve the OPF for this case, and we print the termination status, generation cost and optimal frequencies (The frequency of the standard part of the network is fixed at 60 Hz, and the frequency of the other part is allowed to vary between 1.0 and 100.0 Hz).</p><pre><code class="language-julia">using VariableFrequencyOPF

network = &quot;test/data/case14_twoarea/two_area/&quot;
objective = &quot;mincost&quot;
solution = VariableFrequencyOPF.multifrequency_opf(network, objective)

results_dict = solution[1]
println(&quot;Status:&quot;)
println(results_dict[&quot;status&quot;])
println(&quot;\nCost:\n==============================&quot;)
println(&quot;Variable frequency subnetwork:&quot;)
println(results_dict[&quot;cost&quot;][1])
println(&quot;Fixed frequency subnetwork:&quot;)
println(results_dict[&quot;cost&quot;][2])
println(&quot;\nFrequency:\n==============================&quot;)
println(&quot;Variable frequency subnetwork:&quot;)
println(results_dict[&quot;frequency (Hz)&quot;][1])
println(&quot;Fixed frequency subnetwork:&quot;)
println(results_dict[&quot;frequency (Hz)&quot;][2])</code></pre><p><strong>output:</strong></p><pre><code class="language-none">Status:
LOCALLY_SOLVED

Cost:
==============================
Variable frequency subnetwork:
7565.237470495639
Fixed frequency subnetwork:
553.6125608844086

Frequency:
==============================
Variable frequency subnetwork:
1.0
Fixed frequency subnetwork:
60.0</code></pre><h3 id="Solve-the-OPF-for-a-set-of-upgrades"><a class="docs-heading-anchor" href="#Solve-the-OPF-for-a-set-of-upgrades">Solve the OPF for a set of upgrades</a><a id="Solve-the-OPF-for-a-set-of-upgrades-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-OPF-for-a-set-of-upgrades" title="Permalink"></a></h3><p>We want to define a set of upgrades in the Nordic system, each consisting of a single point-to-point upgrade. We use the function <code>enumerate_branches</code> to create the network data for each upgraded case. This generates a folder of network data for the single network file <code>base_network</code> with one line converted to LFAC, once for each index in <code>indices</code>, or if <code>indices</code> is empty, for every non-transformer branch in the network. Once we have created the data for each of these upgrades, we can call <code>run_series</code> to solve the OPF for each upgrade.</p><pre><code class="language-julia">using VariableFrequencyOPF

original_network = &quot;test/data/nordic_fault/base/fault_4032_4044.m&quot;
# We choose to put the new network data in the same folder because
# we also want to use some data that is already there. Each upgrade
# gets its own folder.
new_data_directory = &quot;test/data/nordic_fault/&quot;
standard_frequency = 50.0
lfac_branch_upgrades = [21,27,28,29,30,31,32,33]

VariableFrequencyOPF.upgrade_branches(
    original_network,
    new_data_directory,
    standard_frequency,
    indices=lfac_branch_upgrades
)

# Minimize generation in areas 2 and 3 with plots including
# the power flow between areas 1 and 2
objective = &quot;areagen&quot;
gen_areas = [2,3]
area_transfer = [1,2]
# We want to plot the results of all branch upgrades,
# so we set `enum_branch` to true
enum_branches = true

solution =  VariableFrequencyOPF.run_series(
    new_data_directory,
    objective;
    gen_areas=gen_areas,
    area_transfer=area_transfer,
    enum_branches=enum_branches
)
results_dict = solution[1]
n_subnets = solution[2]
subnet_array = solution[3]
idx_sorted = solution[4]
series_output_folder = solution[5]
plot_best_x = solution[6]

println(&quot;Ran the OPF for all folders and saved the outputs in $series_output_folder.&quot;)

# Now we generate plots showing the results across all the upgrades.
# We could plot multiple series (e.g. with different operating conditions,
# converter parameters, etc.) on the same x axis by adding them
# to the following array. Here we only plot one.
results_dict_allplots = [results_dict]

plot_output_folder = &quot;results/nordic_fault/&quot;
series_labels = [&quot;LFAC upgrades&quot;]

VariableFrequencyOPF.plot_results_dicts_bar(
    results_dict_allplots,
    n_subnets,
    subnet_array,
    idx_sorted,
    plot_output_folder,
    plot_best_x,
    series_labels,
    color_palette=:Dark2_8
)</code></pre><p>The function <code>run_series</code> solves the OPF for each upgrade and generates results in <em>.csv</em> files. The next function, <code>plot_results_dicts_bar</code>, generates and saves plots of certain variables. For example, we can look at the plot of the objective value, <em>total generation in areas 2 and 3 (p.u.)</em>: <img src="examples/fig/totalgeneration.svg" alt="total generation in areas 2 and 3 (p.u.)"/></p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#VariableFrequencyOPF.frequency_ranges-Tuple{Any,Any,Int64,String,String,Array,Array}"><code>VariableFrequencyOPF.frequency_ranges</code></a></li><li><a href="#VariableFrequencyOPF.make_mn_data-Tuple{Any,Any,Dict{String,Any}}"><code>VariableFrequencyOPF.make_mn_data</code></a></li><li><a href="#VariableFrequencyOPF.multifrequency_opf-Tuple{String,String}"><code>VariableFrequencyOPF.multifrequency_opf</code></a></li><li><a href="#VariableFrequencyOPF.read_sn_data-Tuple{String}"><code>VariableFrequencyOPF.read_sn_data</code></a></li><li><a href="#VariableFrequencyOPF.run_subnets-Tuple{String,String}"><code>VariableFrequencyOPF.run_subnets</code></a></li><li><a href="#VariableFrequencyOPF.upgrade_branches-Tuple{String,String,Any}"><code>VariableFrequencyOPF.upgrade_branches</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.frequency_ranges-Tuple{Any,Any,Int64,String,String,Array,Array}" href="#VariableFrequencyOPF.frequency_ranges-Tuple{Any,Any,Int64,String,String,Array,Array}"><code>VariableFrequencyOPF.frequency_ranges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function frequency_ranges(
    f_min,
    f_max,
    subnet::Int64,
    directory::String,
    objective::String,
    x_axis::Array,
    y_axis::Array;
    gen_areas=Int64[],
    area_transfer=Int64[],
    gen_zones=[],
    zone_transfer=[],
    plot_vert_line::Tuple=([],&quot;&quot;),
    plot_horiz_line::Tuple=([],&quot;&quot;),
    xlimits::Array{Any,1}=[],
    ylimits::Array{Any,1}=[],
    output_plot_label::Tuple{String,String}=(&quot;&quot;,&quot;&quot;),
    scopf::Bool=false,
    contingency::Tuple=(0,),
    k_cond=[],
    k_ins=[],
    scale_load=1.0,
    scale_areas=Int64[],
    no_converter_loss=false
)</code></pre><p>Models and solves an OPF with frequency in specified ranges between <code>f_min</code> and <code>f_max</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f_min</code>: lower bounds on frequency, one for each point in the frequency sweep</li><li><code>f_max</code>: upper bounds on frequency, one for each point in the frequency sweep. Must have the same length as <code>f_min</code>.</li><li><code>subnet::Int64</code>: subnetwork for which the frequency bounds are applied</li><li><code>directory::String</code>: the directory containing all subnetwork data, <em>subnetworks.csv</em>, and <em>interfaces.csv</em></li><li><code>objective::String</code>: the objective function to use, from the following:<ul><li>&quot;mincost&quot;: minimize generation cost</li><li>&quot;areagen&quot;: minimize generation in the areas specified in <code>gen_areas</code></li><li>&quot;zonegen&quot;: minimize generation in the zones specified in <code>gen_zones</code></li><li>&quot;minredispatch&quot;: minimize the change in generator dispatch from the initial values defined in the network data</li></ul></li><li><code>x_axis::Array</code>: Array of Tuples identifying the x axis series for which plots should be generated over the points in the frequency sweep. A separate folder of plots is generated for each Tuple in the array. The series can be specified in the Tuple in one of three ways:<ul><li><strong>results dictionary values:</strong> A two-element Tuple, where the first element is a String matching a key in the results dictionary output from <code>multifrequency_opf</code> and the second element is an Int specifying a subnetwork. This plots the values of this key and subnetwork entry on the x axis.</li><li><strong>network data values:</strong> A Tuple with elements corresponding to keys at each level of the network data dictionary, identifying any network variable value. This plots the values of the specified network variable on the x axis. Any key in the Tuple may be an Array, in which case a separate plot is generated for each key. For example, to generate four plots, the active and reactive power at the origin (&quot;f&quot;) bus and destination (&quot;t&quot;) bus for branch 1 in subnetwork 2, use the Tuple <code>(&quot;sn&quot;,2,&quot;branch&quot;,1,[&quot;pt&quot;,&quot;pf&quot;,&quot;qt&quot;,&quot;qf&quot;])</code></li><li><strong>custom values:</strong> A two-element Tuple, where the first element is a String not matching any keys in the results dictionary and the second element is an Array. This plots the values in the Array on the x axis with the label in the String.</li></ul></li><li><code>y_axis::Array</code>: Array of Tuples identifying the y axis series for which plots should be generated over the points in the frequency sweep. A separate folder of plots is generated for each Tuple in the array. These are specified in the same way as <code>x_axis</code>.</li><li><code>gen_areas</code>: all areas in which generation should be minimized if <code>obj==&quot;areagen&quot;</code></li><li><code>area_transfer</code>: two areas with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two areas. Must have exactly two elements.</li><li><code>gen_zones</code>: all zones in which generation should be minimized if <code>obj==&quot;zonegen&quot;</code></li><li><code>zone_transfer</code>: two zones with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two zones. Must have exactly two elements.</li><li><code>plot_vert_line::Tuple</code>: x values of vertical lines to overlay on the plot. The first element is a scalar or Array specifying one or more x values to plot, and the second element is a String or Array of Strings specifying the label or labels. Default ([],&quot;&quot;) does not add any lines to the plot.</li><li><code>plot_horiz_line::Tuple</code>: y values of horizontal lines to overlay on the plot. The first element is a scalar or Array specifying one or more y values to plot, and the second element is a String or Array of Strings specifying the label or labels. Default ([],&quot;&quot;) does not add any lines to the plot.</li><li><code>xlimits::Array{Any,1}</code>: Array of two values specifying the min and max x axis limits to apply to the plots, overriding any other limits. Default [] does not change the plot.</li><li><code>ylimits::Array{Any,1}</code>: Array of two values specifying the min and max y axis limits to apply to the plots, overriding any other limits. Default [] does not change the plot.</li><li><code>output_plot_label::Tuple{String,String}</code>: specifies the plot to pass to the output. The first element must match the x axis label, and the second must match the y axis label.</li><li><code>scopf::Bool</code>: if true, model and solve the N-1 security constrained OPF for each network. Each network folder must contain a contingency specification file (<em>*.con</em>) for each subnetwork. Default false.</li><li><code>contingency::Tuple</code>: indices of the contingency to plot. The precontingency index is (0,). Default (0,).</li><li><code>k_cond</code>: conductor utilization parameter for HVDC. Only used when f==0. Default [].</li><li><code>k_ins</code>: insulation factor parameter for HVDC. Only used when f==0. Default [].</li><li><code>scale_load</code>: factor for scaling the load in the frequency sweep. Default 1.0.</li><li><code>scale_areas</code>: array of integer area indices for which the load scaling factor <code>scale_load</code> should be applied. Applies to all areas if this array is empty. Default Int64[].</li><li><code>no_converter_loss</code>: override all converter loss parameters specified in the data and replace them with the the lossless converter model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/app/frequency-sweep.jl#LL2-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.make_mn_data-Tuple{Any,Any,Dict{String,Any}}" href="#VariableFrequencyOPF.make_mn_data-Tuple{Any,Any,Dict{String,Any}}"><code>VariableFrequencyOPF.make_mn_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_mn_data(
    subnetworks,
    interfaces,
    networks::Dict{String,Any}
)</code></pre><p>Builds the mn_data dictionary from the specifications of the subnetworks and interfaces DataFrames and the network data in the networks Dict.</p><p><strong>Arguments</strong></p><ul><li><code>subnetworks</code>: a DataFrame in the format of <em>subnetworks.csv</em>, and <em>interfaces.csv</em></li><li><code>interfaces</code>: a DataFrame in the format of <em>interfaces.csv</em></li><li><code>networks::Dict{String,Any}</code>: a Dict of all subnetworks, as PowerModels networks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/core/data-import.jl#LL35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.multifrequency_opf-Tuple{String,String}" href="#VariableFrequencyOPF.multifrequency_opf-Tuple{String,String}"><code>VariableFrequencyOPF.multifrequency_opf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multifrequency_opf(
    folder::String,
    obj::String;
    gen_areas=[],
    area_interface=[],
    gen_zones=[],
    zone_interface=[],
    print_results::Bool=false,
    override_param::Dict{Any}=Dict(),
    fix_f_override::Bool=false,
    direct_pq::Bool=true,
    master_subnet::Int64=1,
    suffix::String=&quot;&quot;,
    start_vals=Dict{String, Dict}(&quot;sn&quot;=&gt;Dict()),
    no_converter_loss::Bool=false,
    uniform_gen_scaling::Bool=false,
    unbounded_pg::Bool=false
)</code></pre><p>Models and solves the OPF for a single network with data contained in <code>folder</code>.</p><p><strong>Arguments</strong></p><ul><li><code>folder::String</code>: the directory containing all subnetwork data, <em>subnetworks.csv</em>, and <em>interfaces.csv</em></li><li><code>obj::String</code>: the objective function to use, from the following:<ul><li>&quot;mincost&quot;: minimize generation cost</li><li>&quot;areagen&quot;: minimize generation in the areas specified in <code>gen_areas</code></li><li>&quot;zonegen&quot;: minimize generation in the zones specified in <code>gen_zones</code></li><li>&quot;minredispatch&quot;: minimize the change in generator dispatch from the initial values defined in the network data</li></ul></li><li><code>gen_areas</code>: integer array of all areas in which generation should be minimized if <code>obj==&quot;areagen&quot;</code></li><li><code>area_interface</code>: two areas with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two areas. Must have exactly two elements.</li><li><code>gen_zones</code>: integer array of all zones in which generation should be minimized if <code>obj==&quot;zonegen&quot;</code></li><li><code>zone_interface</code>: two zones with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two zones. Must have exactly two elements.</li><li><code>print_results::Bool</code>: if true, print the DataFrames containing the output values for buses, branches, generators, and interfaces. These values are always saved to the output <em>.csv</em> files whether true or false.</li><li><code>override_param::Dict{Any}</code>: values to override in the network data defined in <code>folder</code>. Must follow the same structure as the full network data dictionary, beginning with key &quot;sn&quot;. Default empty Dict.</li><li><code>fix_f_override::Bool</code>: if true, fix the frequency in every subnetwork to the base value, overriding the <code>variable_f</code> parameter to <code>variable_f=false</code> for every subnetwork. Default false.</li><li><code>direct_pq::Bool</code>: If direct_pq is false, then the interface is treated as a single node and power flow respects Kirchoff Laws, by constraining the voltage magnitude and angle on each side to be equal and enforcing reactive power balance. Default true.</li><li><code>master_subnet::Int64</code>: if <code>direct_pq==false</code>, the angle reference must be defined for exactly one subnetwork, since the other subnetwork angles are coupled through the interfaces. Value of <code>master_subnet</code> defines which subnetwork provides this reference. Default 1.</li><li><code>suffix::String</code>: suffix to add to the output directory when saving results. Default empty string.</li><li><code>start_vals</code>: Nested dictionary populated with values to be used as a starting point in the optimization model. Applies to bus <code>vm</code> and <code>va</code>, gen <code>pg</code> and <code>qg</code>, branch <code>pt</code>, <code>pf</code>, <code>qt</code> and <code>qf</code> and subnet <code>f</code>. Any of these values which are present in the dictionary will be applied; other values will be ignored. A full network data dictionary can be used. Default <code>Dict{String, Dict}(&quot;sn&quot;=&gt;Dict())</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/core/multifrequency-opf.jl#LL2-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.read_sn_data-Tuple{String}" href="#VariableFrequencyOPF.read_sn_data-Tuple{String}"><code>VariableFrequencyOPF.read_sn_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_sn_data(folder::String)</code></pre><p>Reads a network folder and builds the mn_data dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>folder::String</code>: the path to the folder containing all the network data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/core/data-import.jl#LL2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.run_subnets-Tuple{String,String}" href="#VariableFrequencyOPF.run_subnets-Tuple{String,String}"><code>VariableFrequencyOPF.run_subnets</code></a> — <span class="docstring-category">Method</span></header><section><div><p>run<em>subnets(       parent</em>folder::String,       objective::String;       gen<em>areas::Array=[],       area</em>transfer::Array=[],       gen<em>zones::Array=[],       zone</em>transfer::Array=[],       enum<em>branches::Bool=false,       plot</em>best<em>x::Int64=-1,       scopf::Bool=false,       ctg</em>plots::Array{Int64,1}=[0],       run<em>fix</em>f::Bool=false,       run<em>indir</em>PQ::Bool=false,       print_results::Bool=false    )</p><p>Models and solves an OPF for every network in a directory.</p><p><strong>Arguments</strong></p><ul><li><code>parent_folder::String</code>: a directory containing full network data for one or more networks, each in a folder containing all subnetwork data, <em>subnetworks.csv</em>, and <em>interfaces.csv</em></li><li><code>obj::String</code>: the objective function to use, from the following:<ul><li>&quot;mincost&quot;: minimize generation cost</li><li>&quot;areagen&quot;: minimize generation in the areas specified in <code>gen_areas</code></li><li>&quot;zonegen&quot;: minimize generation in the zones specified in <code>gen_zones</code></li><li>&quot;minredispatch&quot;: minimize the change in generator dispatch from the initial values defined in the network data</li></ul></li><li><code>gen_areas::Array{Int64,1}</code>: all areas in which generation should be minimized if <code>obj==&quot;areagen&quot;</code></li><li><code>area_transfer::Array{Int64,1}</code>: two areas with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two areas. Must have exactly two elements.</li><li><code>gen_zones::Array{Int64,1}</code>: all zones in which generation should be minimized if <code>obj==&quot;zonegen&quot;</code></li><li><code>zone_transfer::Array{Int64,1}</code>: two zones with power transfer between them that should be saved and plotted. Results for P, Q, S, and loss are saved for power transfer between the two zones. Must have exactly two elements.</li><li><code>enum_branches::Bool</code>: if true, collect results from each folder for plotting bar graphs. This is used when the possible branch upgrades have been enumerated and a comparison is desired. Default false.</li><li><code>plot_best_x::Int64</code>: number of results to plot, sorted from smallest to largest objective. If <code>plot_best_x</code> &lt;= 1, the results of all networks which gave feasible solutions are plotted. Default -1.</li><li><code>scopf::Bool</code>: if true, model and solve the N-1 security constrained OPF for each network. Each network folder must contain a contingency specification file (<em>*.con</em>) for each subnetwork. Default false.</li><li><code>ctg_plots::Array{Int64,1}</code>: indices of the contingencies to plot. The base case index is 0. Default [0].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/app/fixf-indirPQ.jl#LL2-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VariableFrequencyOPF.upgrade_branches-Tuple{String,String,Any}" href="#VariableFrequencyOPF.upgrade_branches-Tuple{String,String,Any}"><code>VariableFrequencyOPF.upgrade_branches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function upgrade_branches(
   base_network::String,
   output_location::String,
   fbase;
   indices=[],
   output_type=&quot;input&quot;
   )</code></pre><p>Creates a folder of network data for the network <code>base_network</code> with one line converted to LFAC, one for each index in <code>indices</code>, or if <code>indices</code> is empty, for every non-transformer branch in the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WISPO-POP/VariableFrequencyOPF.jl/blob/83890923270194e6c286f2b92e9f5fe6f6f2e429/src/app/modify-network.jl#LL1-L10">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 February 2021 04:55">Tuesday 16 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
